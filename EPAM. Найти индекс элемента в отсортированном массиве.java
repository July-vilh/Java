
---------------------- Хочу узнать какой номер, какое положение в массиве занимает элемен со значением 20 например ------------------------
  
Данный алгоритм работает с ОТСОРТИРОВАННЫМ МАССИВОМ И делит данный массив пополам и в завсисимости от того искомое число которое нам нужно (больше или меньше) числа
находящегося по середине. Мы отбрасываем либо левую, либо правую часть массива

Затем кусок массива который у нас остался мы также делим пополам и сравниваем есть ли в какой-то части число меньше или больше и т.д.
  
!!!!!!!!!!!!!!!!!!!!!!!!!!!!      Данный вид поиска называется БИНАРНЫЙ ПОИСК   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 

public class Main {
    public static void main(String[] args) {
        int[] SortedArray = {19, 20, 26, 48, 55, 64, 75, 89, 91};
        int[] arrayRandom = {70, 79, 98, 13, 75, 96, 24, 36, 88, 85, 47, 85, 56, 32, 5, 69, 86, 45, 82};
        int key = 20;
        int position = BinarySearch(SortedArray, key);
        System.out.println(key + " position is " + position);

    }

    static int BinarySearch(int[] array, int key) {
        int position = 0;
        int left = 0;
        int right = array.length - 1;

        while (left <= right) {
            int middle = (left + right) / 2;
            if (array[middle] == key) {
                System.out.println("Key found");
                return middle;
            }
            if (array[middle] < key) {
                System.out.println("Cut left hulf");
                left = middle + 1;
            }
            if (array[middle] > key) {
                System.out.println("Cut right hulf");
                right = middle - 1;
            }
        }

        return -1;
    }
}

__________________________________________________________________________________________

----------------------------------------------  ПО КУСКАМ ----------------------------------------------------------------


1. int position = BinarySearch(SortedArray, key);

Тут в методе мы передаем отсортированный массив в котором мы будем производить поиск и ключ (то ест какое значение мы ищем в этом массиве)

___________________________

2. int position = 0;

Позиция это индекс ключа которую пока что мы принимаем за 0

____________________________

3.
int left = 0;
int right = array.length - 1;

Элемент массива который находится максимально слева ( то есть как стартовая точка, с начала) будет равен 0
Элемент массива который находится справа будет выщитываться как длина массива - 1
_______________________________________________

4. while (left <= right) {
            int middle = (left + right) / 2;
            if (array[middle] == key) {
                System.out.println("Key found");
                return middle;
                
 * пока элемент массива слева будет меньше или равен правому 
 - среднее значение будет выщитьваться как (левая часть + правая) / 2
 - если этот элемент является ключом, тогда пишем что ключ найден и возвращаем индекс среднего элемента!
 
 ТУТ 55 НЕ ЯВЛЯЕТСЯ КЛЮЧОМ (20)
 ЗНАЧИТ ИДЕМ ДАЛЬШЕ
 ______________________
 
 5.   if (array[middle] < key) {
                System.out.println("Cut left hulf");
                left = middle + 1;
                
ТУТ МЫ ПРОВЕРЯЕМ 55 МЕНЬШЕ КЛЮЧА (20) ЕСЛИ ДА ТО БУДЕТ РАССЧИТЫВАТЬСЯ КАК 55 +1
НО ОНО НЕ МЕНЬШЕ
ИДЕМ ДАЛЬШЕ

________________

6. if (array[middle] > key) {
                System.out.println("Cut right hulf");
                right = middle - 1;
                
ТУТ МЫ ПРОВЕРЯЕМ 55 БОЛЬШЕ 20 ЕСЛИ ДА ТО ВЫВОДИМ ТО-ТО И ЭТО БУДЕТ РАВНО КАК 55-1 ЭЛЕМЕНТ МАССИВА ТО ЕСТЬ БУДЕТ 48

________________

7. return -1;

ЧТО ВОЗВРАЩАТЬ ЕСЛИ ЭЛЕМЕНТ НЕ БУДЕТ НАЙДЕН

_______________________________________________________________________________-

---------------------------------------------------- ИТОГ: --------------------------------------------------------

Cut right hulf
Key found
20 position is 1
